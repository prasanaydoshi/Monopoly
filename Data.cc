#include "Data.h"
#include <random>


//constructor
Data::Data() : current{nullptr}, bank{nullptr} { }; 		//default

Data::Data(std::istream& is) {					// for loading savefile
	int numPlayers;
	is >> numPlayers;
	for (int i = 0; i < numPlayers; ++i) {
		std::string name;
		char piece;
		int timsCups;
		int money;
		int position;
		is >> name >> piece >> timsCups >> money >> position;
		players.emplace_back(std::make_unique<Player>(name, piece, timsCups, money, poisition));
	}
	std::string tile;
	std::string owner
	int improvLevel;
	while (!is.eof()) {
		iss >> tile >> owner >> improvLevel;
		board.emplace_back(std::make_unique<BoardTiles>(tile, owner, improvLevel);
	}
}

//nested accessors
std::string Data::get_namePlayer(int i) { return *(players[i]).get_name(); }
char Data::get_piecePlayer(int i) { return *(players[i]).get_piece(); }
int Data::get_posPlayer(int i) { return *(players[i]).get_posn(); }

//other methods
int Data::get_NetWorth() {
	int total_val = (*current).get_balance();		// current cash balance of player
	for (const auto& property : owned_properties) {		// going through list of owned properites
		int tileNo = property.second;			//sets tileno to be that being looked at
		total_val += (board[tileNo].first).NetVal();	// adds netval of that property
	}
	return total_val;
}

std::ostream& Data::cur_assets(int i, std::ostream& out) {
	out << "Player Name: " << *current.get_name();
	out << "\nPlayer Balance: " << *current.get_balance();
	out << "\nPlayer Properties:\n	";
	int owned = *current.No_ownedProperties();
	int tileNo = 0;
	for (int propNo = 0; propNo <= owned; ++propNo) {
		tileNo = *current.get_tileNo(propNo);
		out << *current.get_name() << "     with improvements: ";
		out << *current.get_impLevel() << "\n";
	}
	return out;
}

std::ostream& Data::owned_assets(int i, std::ostream& out) {
	out << "Player Name: " << *(players[i]).get_name();
	out << "\nPlayer Balance: " << *(players[i]).get_balance();
	out << "\nPlayer Properties:\n	";
	int owned = *(players[i]).No_ownedProperties();
	int tileNo = 0;
	for (int propNo = 0; propNo <= owned; ++propNo) {
		tileNo = *(players[i]).get_tileNo(propNo);
		out << *(board[tileNo]).get_name() << "     with improvements: ";
		out << *(board[tileNo]).get_impLevel() << "\n";
	}
	return out;
}

void Data::save(std::ostream& os) const {
	os << players.size() << '\n';
	for (const auto& player : players) {
		os << player->getName() << player->getPiece() << ' ' << player->getTimsCups();
	        os << ' ' << player->getMoney() << ' ' << player->getPosition() << '\n';
	}


//non-purchasable tile methods
void Data::TuitionPay(bool Pay300) {				// view will ask player if they want
								// to pay 300 or 10% of netval	
	if ( (*current).get_posn() == 24) {
		if (Pay300 == true) {
			(*current).change_balance(-300);
		} else {
			int net = get_NetWorth();
			(*current).change_balance(net);
		}
	}
}

void Data::CoopFee() {
	if ( (*current).get_posn() == 18) {
		(*current).change_balance(-150);
	}
}

void Data::OSAPcol() {
	if ( (*current).get_posn() == 20) {
		(*current).change_balance(200);
	}
}

void Data::TimsJail() { 			
	//REQUIRES ROLL FUNCTION
	if ( (*current).get_posn() == 30) {
	}
}

void Data::GoToJail() {
	if ( (*current).get_posn() == 10) {
		(*current).JumpTo_posn(30);
	}
};

void Data::SLC() {
	if ( ( (*current).get_posn() == 13) || ( (*current).get_posn() == 13) ){
		std::random_device rd;
		std::mt19937 gen(rd());
		std::discrete_distribution<> d({1.0 / 8, 1.0 / 6, 1.0 / 6, 1.0 / 8,
			       	1.0 / 6, 1.0 / 6, 1.0 / 24, 1.0 /24});
		int num_pick = d(gen);			// REQUIRES RANDOM PICKING WITH %CHANCE
		switch(num_pick) {
			case 0:
				(*current).MovePosn_by(-3);		// back3
				break;
			case 1:
				(*current).MovePosn_by(-2);		// back2
				break;
			case 2:
				(*current).MovePosn_by(-1);		// back1
				break;
			case 3: 
				(*current).MovePosn_by(1);		// foreward1
				break;
			case 4: 
				(*current).MovePosn_by(2);		// foreward2
				break;
			case 5: 
				(*current).MovePosn_by(3);		// foreward3
				break;
			case 6: 
				(*current).JumpTo_posn(30);		// DC Tims Line
				break;
			case 7: 
				(*current).MovePosn_by(20);		// Collect OSAP
				break;
		}
	}
}

void Data::NH() {
	if (( (*current).get_posn() == 2) || ( (*current).get_posn() == 16) ){
		std::random_device rd;
		std::mt19937 gen(rd());
		std::discrete_distribution<> d({1.0 / 18, 1.0 / 9, 1.0 / 6, 1.0 / 3,
			       	1.0 / 6, 1.0 / 9, 1.0 / 18});
		int num_pick = d(gen);	
		switch(num_pick) {
			case 0:
				(*current).change_balance(-200);	 
				break;
			case 1:
				(*current).change_balance(-100);
				break;
			case 2:
				(*current).change_balance(-50);
				break;
			case 3:
				(*current).change_balance(25);	
				break;
			case 4: 
				(*current).change_balance(50);
				break;
			case 5: 
				(*current).change_balance(100);		
				break;
			case 6: 
				(*current).change_balance(200);
				break;
		}
	}
}

